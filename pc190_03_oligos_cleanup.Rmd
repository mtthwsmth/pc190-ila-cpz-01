---
title: "pc190_03_oligos_cleanup"
author: "Matthew Smith"
date: "2025-10-24"
output:
  html_document:
    toc: true
    toc_depth: 4
    toc_float:
      collapsed: true
      position: right
    theme: united
    df_print: kable
knitr:
  opts_chunk:
    warning: false
    message: false
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Setup

### Libraries

```{r}
library(tidyverse)
library(qs2)
library(scuttle)
library(clustree)
library(patchwork)
library(Seurat)
library(scCustomize)
source("mds_scRNAseq_functions.R")
```

### Workspace

```{r}
options(future.globals.maxSize = 30000*1024^2) # 30 GB
```

### Data Shortcut

## Cleaning OL - Rd2

I'm calling the subsetting Rd1. So first round cleaning is Rd2.

Import the seurat object created in rmd02 by clustering all cells from 10x filtered
features, then running clustering and subsetting to the clusters that looked like
they might contain some OL.

### Load subsetted so

```{r}
so <- qs_read(
  "06_data_objects/pc190_02_so_rd1_oligos.qs2"
)
```

How many cells?

```{r}
so
table(so$orig.ident)
```

Starting with 65,304 cells. Definitely weighted towards naive, particularly N3.

## Process Oligo Lineage Rd2

We're calling Rd1 the work done in Rmd02. So we start Rd2 here.

### Seurat Pipeline Rd2

First, just use a normal Seurat pipeline. Split by orig.ident

```{r}
so[["RNA"]] <- split(so[["RNA"]], f = so$orig.ident)
```

Then LogNormalize, HVGs per layer, ScaleData, PCA, UMAP on 25 dims, Graph
on 25 dims, Find Clusters at resolution of 0.1 and 0.2.

```{r}
so <- NormalizeData(so) %>% FindVariableFeatures() %>% ScaleData() %>%
  RunPCA() %>% RunUMAP(dims = 1:25) %>% FindNeighbors(dims = 1:25)
so <- FindClusters(so, resolution = c(0.1, 0.2))
so <- RunTSNE(so, dims = 1:25)
```

#### Inspect UMAP Rd2

Inspect metadata variables on the umap.

```{r}
p1 <- DimPlot_scCustom(
  so,
  group.by = "group",
  label = TRUE
  )
p1
p2 <- DimPlot_scCustom(
  so,
  group.by = "orig.ident",
  label = FALSE
  )
p2
p3 <- DimPlot_scCustom(
  so,
  group.by = "dbl_class",
  label = TRUE
  ) + NoLegend()
p3
```

We have a strong seperation of N vs V/T in the main island. Connected to a smaller
island (OPCs) where T/V are most of the cells.

Then have 3 very distinact islands and a 4th slightly less distinct island.

Inspect clusters on UMAP at both resolutions.

```{r}
p1 <- DimPlot_scCustom(
  so,
  group.by = "RNA_snn_res.0.1",
  label = TRUE
  )
p1
p2 <- DimPlot_scCustom(
  so,
  group.by = "RNA_snn_res.0.2",
  label = TRUE
)
p2
```

The resolution doesn't matter much for the 3 most distinct islands - 2,3,4
(4/5/6 at 0.2).

7/5 at 0.1, or 7/8 is the trickiest part.

#### Inspect Res0.1 clusters with Pivot Tables

Inspect the clusters with pivot tables.

```{r}
p1 <- propmap(
  so,
  group.by = "RNA_snn_res.0.1",
  features = "orig.ident",
  title = "RNA_snn_res.0.1 vs orig.ident"
)
p1
p2 <- propmap(
  so,
  group.by = "RNA_snn_res.0.1",
  features = "group",
  title = "RNA_snn_res.0.1 vs group"
)
p2
p3 <- propmap(
  so,
  group.by = "RNA_snn_res.0.1",
  features = "dbl_class",
  title = "RNA_snn_res.0.1 vs dbl_class"
)
p3
p4 <- propmap(
  so,
  group.by = "RNA_snn_res.0.1",
  features = "batch",
  title = "RNA_snn_res.0.1 vs batch"
)
p4
```

cluster 8 has almost no Naive, but split across CPZ groups (but not V_1).
Clusters 2 and 7 are most strongly doublets. 3 and 4 are more mixed. Then 8 and 5.

#### Examine Clusters 0.1 Gene Expression

Examine gene expression of clusters at the 0.1 resolution. Store some marker genes.

```{r}
genes_markers_ol <- c("Mbp", "Plp1", "Opalin")
genes_markers_opc <- c("Pdgfra", "Cspg4", "Matn4")
genes_markers_astro <- c("Gfap", "Aqp4", "Aldh1l1")
genes_markers_micro <- c("Ptprc", "P2ry12", "Itgam")
# genes_markers_neuro <- c("Snap25", "Syt1", "Eno2", "Syn1")

genes_markers_all <- c(
  genes_markers_ol,
  genes_markers_opc,
  genes_markers_astro,
  genes_markers_micro
)
```

Plot marker genes on Stacked VlnPlots.

```{r}
p1 <- Stacked_VlnPlot(
  so,
  features = c(genes_markers_ol),
  group.by = "RNA_snn_res.0.1",
)
p1
p2 <- Stacked_VlnPlot(
  so,
  features = c(genes_markers_opc),
  group.by = "RNA_snn_res.0.1",
)
p2
p3 <- Stacked_VlnPlot(
  so,
  features = c(genes_markers_astro),
  group.by = "RNA_snn_res.0.1",
)
p3
p4 <- Stacked_VlnPlot(
  so,
  features = c(genes_markers_micro),
  group.by = "RNA_snn_res.0.1",
)
p4
```

OL: 0, 2, 3, 5, 6, 8.
OPC: 1, 7, ~5 (MATN4)
Astrocyte: 2,4,7
Microglia: 3,4

Conclusion:
Doublets - 2,3,4,7
OPCs - 1
OL - 0, 6, 8
Transition - 5

Confirm these with a DotPlot

```{r}
p1 <- DotPlot_scCustom(
  so,
  features = c(
    genes_markers_ol,
    genes_markers_opc,
    genes_markers_astro,
    genes_markers_micro
  ),
  group.by = "RNA_snn_res.0.1",
  x_lab_rotate = TRUE
)
p1
```

##### What about neurons?

What about neurons? Some neuronal markers are highly expressed here but don't
change much across the clusters. I think it's ambient RNA. In white matter
tracts we're using to seeing myelin genes as the primary abmient RNA, but maybe
when you include as much grey matter as we did here we get a lot more neuronal
as well? This is consistent with other papers I've seen.

Show neuron gene expression for the record:

```{r}
p1 <- Stacked_VlnPlot(
  so,
  features = c("Snap25", "Rbfox3", "Stmn2", "Syn1"),
  group.by = "RNA_snn_res.0.1",
)
p1
```

Given the absence of NeuN, Stmn2, or Syn1 think it's safe to not worry about
neuronal clusters here. I think we have so much neuronal nuclei in the dataset
that the neuron doublets cluster with the neurons.

## Cleaning OL - Rd3

### Subset and clean Rd2

Store the cluster information.

```{r}
so$clusters_rd2_res01 <- so$RNA_snn_res.0.1
```

Save to disk.

```{r eval=FALSE}
qs_save(
  so,
  "06_data_objects/pc190_03_so_rd2_oligos.qs2"
)
so <- qs_read(
  "06_data_objects/pc190_03_so_rd2_oligos.qs2"
)
```

Subset. We are keeping, 0,1,5,6,8.

```{r}
Idents(so) <- "RNA_snn_res.0.1"
so_rd3 <- subset(
  so,
  idents = c("0", "1", "5", "6", "8")
)
so_rd3 <- JoinLayers(so_rd3)
so_rd3 <- cleanSeurat_mds(
  so_rd3,
  removeClustering = TRUE,
  clusteringPrefix = "RNA_snn_res."
)
so_rd3
```

Now have 57,075 nuclei.

### Process Rd 3

Again use the regular pipeline.

```{r}
so_rd3[["RNA"]] <- split(so_rd3[["RNA"]], f = so_rd3$orig.ident)
so_rd3 <- NormalizeData(so_rd3)
so_rd3 <- FindVariableFeatures(so_rd3)
so_rd3 <- ScaleData(so_rd3)
so_rd3 <- RunPCA(so_rd3)
so_rd3 <- RunUMAP(so_rd3, dims = 1:25)
so_rd3 <- RunTSNE(so_rd3, dims = 1:25)
```

#### Inspect UMAP Rd3

```{r}
p1 <- DimPlot_scCustom(
  so_rd3,
  group.by = "group",
  label = TRUE
)
p1
p2 <- DimPlot_scCustom(
  so_rd3,
  group.by = "orig.ident",
  label = FALSE
)
p2
p3 <- DimPlot_scCustom(
  so_rd3,
  group.by = "dbl_class",
  label = TRUE
)
p3
```

Largely the same shape as Rd2 with distinct islands. Still 1 though, in addition
to the OPC to OL shapes.

This was the case before, but N_3 is clustering quite distinctly in the OL,
if we want to subcluster the OL we'll probably have to integrate on PPID?

Inspect QC Metrics on the UMAP

```{r}
p1 <- FeaturePlot_scCustom(
  so_rd3,
  feature = "nFeature_RNA",
  reduction = "umap"
)
p1
p2 <- FeaturePlot_scCustom(
  so_rd3,
  feature = "nCount_RNA",
  reduction = "umap"
)
p2
p3 <- FeaturePlot_scCustom(
  so_rd3,
  feature = "percent_mito",
  reduction = "umap"
)
p3
```

Overall looks ok, definitely have a distinct area of high mitochondrial that
we will have to remove.

### Cluster Rd 3

Cluster at resolution 0.1.

```{r}
so_rd3 <- FindNeighbors(so_rd3, dims = 1:25)
so_rd3 <- FindClusters(so_rd3, resolution = 0.1)
```
Inspect the clusters.

```{r}
p1 <- DimPlot_scCustom(
  so_rd3,
  group.by = "RNA_snn_res.0.1",
  label = TRUE
)
p1
```

these are fairly distinct. What is cluster 4?

```{r}
markers_rd3_res01_c04 <- FindMarkers(
  JoinLayers(so_rd3),
  ident.1 = 4,
  min.pct = 0.50,
  logfc.threshold = 0.25
) %>% Add_Pct_Diff()

head(markers_rd3_res01_c04, n = 10)
```

They are microglia.

What to do about the rest? I think we split the OPC and OL into different datasets
for now, can put them back together later when they're cleaned up more.

But what to do about the transition population?

I think keep it out of both for now. It's 1270 cells. 0 is 41516. 1 is 7059. 2
is 6799. WE have a lot more OL here than the others.

## Cleaning OL - OL only Rd4

Remove clusters 1,3, and 4.

```{r}
Idents(so_rd3) <- "RNA_snn_res.0.1"
so_ol_rd4 <- subset(
  so_rd3,
  idents = c("0", "2")
)
so_ol_rd4 <- JoinLayers(so_ol_rd4)
so_ol_rd4 <- cleanSeurat_mds(
  so_ol_rd4,
  removeClustering = TRUE,
  clusteringPrefix = "RNA_snn_res."
)
so_ol_rd4
```
Now down to 48,315 cells.

### MAD based thresholding

Calculate thresholds based on MAD for nFeature_RNA, nCount_RNA, percent_mito.

```{r}
outliers_ol <- perCellQCFilters(
  x = DataFrame(so_ol_rd4@meta.data),
  sum.field = "nCount_RNA",
  detected.field = "nFeature_RNA",
  sub.fields = "percent_mito",
  batch = so_ol_rd4$orig.ident
)

rownames(outliers_ol) <- colnames(so_ol_rd4)

so_ol_rd4 <- AddMetaData(
  so_ol_rd4,
  metadata = as.data.frame(outliers_ol),
  col.name = c("low_lib_size", "low_n_features", "high_percent_mito", "discard")
)
```

#### Make a pivot table per sample

```{r}
qc_cols <- c("low_lib_size", "low_n_features", "high_percent_mito", "discard")
pivot_summary_ol <- so_ol_rd4@meta.data %>%
  group_by(orig.ident) %>%
  summarise(
    # counts for each QC flag
    across(all_of(qc_cols), ~ sum(.x, na.rm = TRUE), .names = "n_{.col}"),
    # proportions for each QC flag
    across(all_of(qc_cols),
           ~ round(mean(.x, na.rm = TRUE)*100, 1), .names = "prop_{.col}"),
    # combo: (low_lib_size OR low_n_features) AND high_percent_mito
    n_lib_and_mito   = sum((low_lib_size | low_n_features) & high_percent_mito, na.rm = TRUE),
    prop_lib_and_mito = round(
      mean(
        (low_lib_size | low_n_features) & high_percent_mito, na.rm = TRUE
        ) * 100, 1
      ),
    .groups = "drop"
  )
pivot_summary_ol
```

#### Inspect MAD based thresholding per sample on each QC metric.

```{r}
p1 <- plotSeuratColData(
  so_ol_rd4,
  x = "orig.ident",
  y = "nFeature_RNA",
  colour_by = "discard",
)
p1
p2 <- plotSeuratColData(
  so_ol_rd4,
  x = "orig.ident",
  y = "nCount_RNA",
  colour_by = "discard",
)
p2
p3 <- plotSeuratColData(
  so_ol_rd4,
  x = "orig.ident",
  y = "percent_mito",
  colour_by = "discard",
) + scale_y_continuous(trans = "log1p") +
  geom_hline(yintercept = 1, color = "red")
p3 
```



### Process OL Rd4

Now use two pipelines and compare the results - LogNorm and SCTransform.

#### Seurat LogNorm OL Rd4

```{r}
so_ol_rd4[["RNA"]] <- split(so_ol_rd4[["RNA"]], f = so_ol_rd4$orig.ident)
so_ol_rd4 <- NormalizeData(so_ol_rd4)
so_ol_rd4 <- FindVariableFeatures(so_ol_rd4)
so_ol_rd4 <- ScaleData(so_ol_rd4)
so_ol_rd4 <- RunPCA(so_ol_rd4, reduction.name = "pca_log")
so_ol_rd4 <- RunUMAP(so_ol_rd4,
                     reduction = "pca_log",
                     reduction.name = "umap_log",
                     dims = 1:25)
so_ol_rd4 <- RunTSNE(so_ol_rd4,
                     reduction = "pca_log",
                     reduction.name = "tsne_log",
                     dims = 1:25)
```

#### Seurat SCTransform OL Rd4

Now also perform SCTransform for comparisons sake.

```{r}
so_ol_rd4 <- SCTransform(so_ol_rd4)
so_ol_rd4 <- RunPCA(so_ol_rd4, reduction.name = "pca_sct")
so_ol_rd4 <- RunUMAP(so_ol_rd4,
                     reduction = "pca_sct",
                     reduction.name = "umap_sct",
                     dims = 1:25)
so_ol_rd4 <- RunTSNE(so_ol_rd4,
                     reduction = "pca_sct",
                     reduction.name = "tsne_sct",
                     dims = 1:25)
```

#### Inspect UMAP Rd4 - LogNorm vs SCTransform

Inspect the UMAP created from the LogNorm data.

```{r}
p1 <- DimPlot_scCustom(
  so_ol_rd4,
  reduction = "umap_log",
  group.by = "group",
  label = TRUE
)
p1
p2 <- DimPlot_scCustom(
  so_ol_rd4,
  reduction = "umap_log",
  group.by = "orig.ident",
  label = FALSE
)
p2
p3 <- DimPlot_scCustom(
  so_ol_rd4,
  reduction = "umap_log",
  group.by = "dbl_class",
  label = TRUE
)
p3
```

Inspect the UMAP created from the SCT data.

```{r}
p1 <- DimPlot_scCustom(
  so_ol_rd4,
  reduction = "umap_sct",
  group.by = "group",
  label = TRUE
)
p1
p2 <- DimPlot_scCustom(
  so_ol_rd4,
  reduction = "umap_sct",
  group.by = "orig.ident",
  label = FALSE
)
p2
p3 <- DimPlot_scCustom(
  so_ol_rd4,
  reduction = "umap_sct",
  group.by = "dbl_class",
  label = TRUE
)
p3
```

The SCTransform, when done on a per sample basis, is doing a pretty good job
of itnegrating V_3 on its own without further processing.

There's also shape to the UMAP that isn't present in the LogNorm data. There's
some seperating islands, that particularly enrich for the Naive condition.

Inspect QC metrics on the SCT UMAP

```{r}
p1 <- FeaturePlot_scCustom(
  so_ol_rd4,
  feature = "nFeature_RNA",
  reduction = "umap_sct"
)
p1
p2 <- FeaturePlot_scCustom(
  so_ol_rd4,
  feature = "nCount_RNA",
  reduction = "umap_sct"
)
p2
p3 <- FeaturePlot_scCustom(
  so_ol_rd4,
  feature = "percent_mito",
  reduction = "umap_sct"
)
p3
```

Inspec them on the LogNorm map too for comparisons sake.

```{r}
p1 <- FeaturePlot_scCustom(
  so_ol_rd4,
  feature = "nFeature_RNA",
  reduction = "umap_log"
)
p1
p2 <- FeaturePlot_scCustom(
  so_ol_rd4,
  feature = "nCount_RNA",
  reduction = "umap_log"
)
p2
p3 <- FeaturePlot_scCustom(
  so_ol_rd4,
  feature = "percent_mito",
  reduction = "umap_log"
)
p3
```



#### Cluster Ol Rd4 - SCT

Cluster the SCT data at resolution 0.1 - 1.

```{r}
so_ol_rd4 <- FindNeighbors(
  so_ol_rd4,
  reduction = "pca_sct",
  dims = 1:25
)
so_ol_rd4 <- FindClusters(
  so_ol_rd4,
  resolution = seq(0.1:1, by = 0.1),
  verbose = FALSE
)
```

Inspect the SCT clustering at the 9 resolutions on SCT based UMAP

```{r}
p1 <- DimPlot_scCustom(
  so_ol_rd4,
  reduction = "umap_sct",
  group.by = "SCT_snn_res.0.1",
  label = TRUE
)
p1
p2 <- DimPlot_scCustom(
  so_ol_rd4,
  reduction = "umap_sct",
  group.by = "SCT_snn_res.0.2",
  label = TRUE
)
p2
p3 <- DimPlot_scCustom(
  so_ol_rd4,
  reduction = "umap_sct",
  group.by = "SCT_snn_res.0.3",
  label = TRUE
)
p3
p4 <- DimPlot_scCustom(
  so_ol_rd4,
  reduction = "umap_sct",
  group.by = "SCT_snn_res.0.4",
  label = TRUE
)
p4
p5 <- DimPlot_scCustom(
  so_ol_rd4,
  reduction = "umap_sct",
  group.by = "SCT_snn_res.0.5",
  label = TRUE
)
p5
p6 <- DimPlot_scCustom(
  so_ol_rd4,
  reduction = "umap_sct",
  group.by = "SCT_snn_res.0.6",
  label = TRUE
)
p6
p7 <- DimPlot_scCustom(
  so_ol_rd4,
  reduction = "umap_sct",
  group.by = "SCT_snn_res.0.7",
  label = TRUE
)
p7
p8 <- DimPlot_scCustom(
  so_ol_rd4,
  reduction = "umap_sct",
  group.by = "SCT_snn_res.0.8",
  label = TRUE
)
p8
p9 <- DimPlot_scCustom(
  so_ol_rd4,
  reduction = "umap_sct",
  group.by = "SCT_snn_res.0.9",
  label = TRUE
)
p9
p10 <- DimPlot_scCustom(
  so_ol_rd4,
  reduction = "umap_sct",
  group.by = "SCT_snn_res.1",
  label = TRUE
)
p10

```

We obviously have a small set of cells that have very high mito percentages. It
seperates out as cluster at 0.1, but then becomes part of the bigger adjacent
cluster until 0.9 when it seperates out again as 18, maintained as 1.0.

For now use resolution 0.9.

Do the same thing as above but for the TSNE. Only look at resolution 0.1, 0.2,
0.7, 0.8, 0.9.

```{r}
p1 <- DimPlot_scCustom(
  so_ol_rd4,
  reduction = "tsne_sct",
  group.by = "SCT_snn_res.0.1",
  label = TRUE
)
p1
p2 <- DimPlot_scCustom(
  so_ol_rd4,
  reduction = "tsne_sct",
  group.by = "SCT_snn_res.0.2",
  label = TRUE
)
p2
p3 <- DimPlot_scCustom(
  so_ol_rd4,
  reduction = "tsne_sct",
  group.by = "SCT_snn_res.0.7",
  label = TRUE
)
p3
p4 <- DimPlot_scCustom(
  so_ol_rd4,
  reduction = "tsne_sct",
  group.by = "SCT_snn_res.0.8",
  label = TRUE
)
p4
p5 <- DimPlot_scCustom(
  so_ol_rd4,
  reduction = "tsne_sct",
  group.by = "SCT_snn_res.0.9",
  label = TRUE
)
p5
p6 <- DimPlot_scCustom(
  so_ol_rd4,
  reduction = "tsne_sct",
  group.by = "SCT_snn_res.1",
  label = TRUE
)
p6

```

Use the 1.0 resolution. 

Inspect the clusters at this resolution for QC metrics. Colour by MAD based
threhsolding.

```{r}
p1 <- plotSeuratColData(
  so_ol_rd4,
  x = "SCT_snn_res.1",
  y = "percent_mito",
  colour_by = "discard",
) + scale_y_continuous(trans = "log1p") + geom_hline(yintercept = 1, color = "red")
p1
p2 <- plotSeuratColData(
  so_ol_rd4,
  x = "SCT_snn_res.1",
  y = "nFeature_RNA",
  colour_by = "discard",
)
p2
p3 <- plotSeuratColData(
  so_ol_rd4,
  x = "SCT_snn_res.1",
  y = "nCount_RNA",
  colour_by = "discard",
)
p3
p4 <- plotSeuratColData(
  so_ol_rd4,
  x = "SCT_snn_res.1",
  y = "nFeature_RNA",
  colour_by = "dbl_class",
)
p4
```
Cluster 18 is quite distinct and easy discard on mitochondrial percentages.
What bout cluster 7 though? It's not nearly as high, but still almost 100%
outisde MAD based mito_percent thresholding.

It's also a lot of cells - 2650.

How big are these clusters?

```{r}
table(so_ol_rd4$SCT_snn_res.1)
```

How are the clusters made up by metadata variables?

```{r}
p1 <- propmap(
  so_ol_rd4,
  group.by = "SCT_snn_res.1",
  features = "group",
  title = "Res1 x Group")
p1
p2 <- propmap(
  so_ol_rd4,
  group.by = "SCT_snn_res.1",
  features = "orig.ident",
  title = "Res1 x Orig.Ident"
)
p2
p3 <- propmap(
  so_ol_rd4,
  group.by = "SCT_snn_res.1",
  features = "batch",
  title = "Res1 x Batch"
)
p3
p4 <- propmap(
  so_ol_rd4,
  group.by = "SCT_snn_res.1",
  features = "dbl_class",
  title = "Res1 x Dbl_Class"
)
p4
```

Overall enrichment in Naive, but depleted in 6, 11, 16, 17, 19.
6 is a little more enriched in T than V? (overall T is 26%, V is 24%). This is
driven by T_2 and T_4.
Batches don't look too bad. 13 is enriched in 13, also cluster 19.
18 and 19 are the two clusters enriched in doublets (20-30%).

##### Rd4 High Mito Cluster - res1 cluster 18

Cluster 18 is 282 cells and obviously high mitochondrial, exclude in subsequent
steps.

##### Rd4 Mid Mito Cluster - res1 cluster 7

Cluster 7 gets almost entirely labeled as MAD outlier based on percent_mito

It's not wildly high though like cluster 18 is. It's around 1%, some above, some
below.

Where is it on the dim reductions?

```{r}
p1 <- Cluster_Highlight_Plot(
  so_ol_rd4,
  cluster_name = "7",
  reduction = "umap_sct",
  group.by = "SCT_snn_res.1",
)
p1
p2 <- Cluster_Highlight_Plot(
  so_ol_rd4,
  cluster_name = "7",
  reduction = "tsne_sct",
  group.by = "SCT_snn_res.1",
)
p2
```

So before discarding it, check it for markers.

```{r}
DefaultAssay(so_ol_rd4) <- "RNA"
markers_ol_rd4_res01_c07 <- FindMarkers(
  JoinLayers(so_ol_rd4),
  ident.1 = "7",
  min.pct = 0.5,
  logfc.threshold = 0.5,
  only.pos = TRUE
) %>% Add_Pct_Diff()

head(markers_ol_rd4_res01_c07, n = 10)
```
It has only 6 markers, and they are all mitochondrial genes. 

How many nuclei that are not in cluster 7 or 18 are still discards based on MADs?

```{r}
sum(
  so_ol_rd4$discard &
    !(so_ol_rd4$SCT_snn_res.1 %in% c("7", "18"))
)
```

Out of 5601, 2901 (51%) are in clusters 7 and 18.

Discard. cluster 7.

##### Rd4 COP - res1 cluster 19

What about cluster 19 here? It's quite distinct on the UMAP. Only 152 cells.

```{r}
DefaultAssay(so_ol_rd4) <- "RNA"
Idents(so_ol_rd4) <- "SCT_snn_res.1"
markers_ol_rd4_res10_c19 <- FindMarkers(
  JoinLayers(so_ol_rd4),
  ident.1 = "19",
  min.pct = 0.5,
  logfc.threshold = 0.5,
  onlny.pos = TRUE
) %>% Add_Pct_Diff()
head(markers_ol_rd4_res10_c19, n = 10)
```

Plot expression of top 4 markers.

```{r}
p1 <- VlnPlot_scCustom(
  so_ol_rd4,
  features = rownames(markers_ol_rd4_res10_c19)[1:4],
  num_columns = 2,
  pt.size = 0
)
p1
```

Note from above pivot tables this was enriched in CPZ conditions as well.

##### Rd4 High Library Size - NFOL

11 and 17 both have much alrger library sizes than all the other clusters. 1902
+ 292 cells. These split from 1 cluster at resolution 0.8.

How do these look on the dim reductions?

```{r}
p1 <- Cluster_Highlight_Plot(
  so_ol_rd4,
  cluster_name = c("11", "17"),
  reduction = "umap_sct",
  group.by = "SCT_snn_res.1",
)
p1
p2 <- Cluster_Highlight_Plot(
  so_ol_rd4,
  cluster_name = c("11", "17"),
  reduction = "tsne_sct",
  group.by = "SCT_snn_res.1",
)
p2
```

Find markers for these two clusters together vs the rest.

```{r}
Idents(so_ol_rd4) <- "SCT_snn_res.1"
DefaultAssay(so_ol_rd4) <- "RNA"
markers_ol_rd4_res10_c11_17 <- FindMarkers(
  JoinLayers(so_ol_rd4),
  ident.1 = c("11", "17"),
  min.pct = 0.5,
  logfc.threshold = 0.5,
  only.pos = TRUE
) %>% Add_Pct_Diff()
head(markers_ol_rd4_res10_c11_17, n = 10)
```

Man1a and Synpr both point to NFOL. Kind of makes sense with where they are in
the plots. I bet in so_rd3 they will be where the transition connects.

```{r}
p1 <- DimPlot(
    so_rd3,
    cells.highlight = WhichCells(
      object = so_ol_rd4,
      idents = c("11", "17")
    )
  )
p1
```

Plot exression of a few markers as well.

```{r}
p1 <- VlnPlot_scCustom(
  so_ol_rd4,
  features = rownames(markers_ol_rd4_res10_c11_17)[1:4],
  num_columns = 2,
  pt.size = 0
)
p1
```

#### Rd4 Non-Cluster Based Discards - MAD and Dbl

We have two low quality clusters - 7 and 18 (based on Mito). We have a cluster
of cells that look more like OPCs - cluster 19. Discard those 3 clusters. How
many is that?

```{r}
sum(so_ol_rd4$SCT_snn_res.1 %in% c("7", "18", "19"))
```


We'll keep the NFOL clusters.

Now, should we discard cells based on MADs or doublet classification regardless
of clusters?

How many would that be?

```{r}
sum(
  ( so_ol_rd4$discard |
    so_ol_rd4$dbl_class == "Doublet" ) &
    !(so_ol_rd4$SCT_snn_res.1 %in% c("7", "18", "19"))
)
```

In this rd we're starting with 48315 nuclei.
Discard 3084 based on clustering (6%)
Discard another 2690 basd on algorithmic detection (6%)

So discarding 12% total.

Inspect where these show up on the dim reductions.

```{r}
cells_rd4_algo_discard <- WhichCells(
  so_ol_rd4,
  expression = ( discard | dbl_class == "Doublet" ) &
    !(SCT_snn_res.1 %in% c("7", "18", "19"))
)
p1 <- DimPlot(
  so_ol_rd4,
  cells.highlight = list("Algo Discard" = cells_rd4_algo_discard),
  reduction = "umap_sct",
  group.by = "SCT_snn_res.1"
) + ggtitle("UMAP SCT Algorithmic Discards")
p1
p2 <- DimPlot(
  so_ol_rd4,
  cells.highlight = list("Algo Discard" = cells_rd4_algo_discard),
  reduction = "tsne_sct",
  group.by = "SCT_snn_res.1"
) + ggtitle("TSNE SCT Algorithmic Discards")
p2
```

sum()

None of the clusters look problematic by any of these metrics so far at least.

Should we drop doublets? Or low library 

## Save Cleaned OL Object

Subset out the discarded cells.

```{r}
Idents(so_ol_rd4) <- "SCT_snn_res.1"
so_ol_rd4$clusters_rd4_sct_res1 <- so_ol_rd4$SCT_snn_res.1
so_ol_cleaned <- subset(
  so_ol_rd4,
  subset = !(SCT_snn_res.1 %in% c("7", "18", "19")) &
    !discard &
    dbl_class != "Doublet"
)
so_ol_cleaned <- JoinLayers(so_ol_cleaned)
so_ol_cleaned <- cleanSeurat_mds(
  so_ol_cleaned,
  removeClustering = TRUE,
  clusteringPrefix = "SCT_snn_res"
)
so_ol_cleaned
# we still have some RNA clusters from point, remove those
so_ol_cleaned@meta.data[
  ,
  grepl(pattern = "^RNA_snn_res", x = colnames(so_ol_cleaned@meta.data))
] <- NULL
```

Save the so and the cells to disk.

```{r eval=FALSE}
qs_save(
  so_ol_cleaned,
  "06_data_objects/pc190_03_so_oligos_cleaned.qs2"
)
saveRDS(
  colnames(so_ol_cleaned),
  file = "06_data_objects/pc190_cells_so_oligos_cleaned.rds"
)
```

## Cleaning OPC Only - Rd4

Also clean up the OPCs here. From Rd3, cluster 1 is OPCs, cluster 3 is
transitioning?

Plus, from ol_rd4, cluster 19 is COPs which I did not include in that analysis
so I should include them ehre? Maybe?

### Subset to putative OPCs Rd4

Make a list of cells here.

```{r}
Idents(so_rd3) <- "RNA_snn_res.0.1"
cells_opc_rd4_from_rd3 <- WhichCells(
  so_rd3,
  idents = c("1", "3")
)
Idents(so_ol_rd4) <- "SCT_snn_res.1"
cells_opc_rd4_from_rd4 <- WhichCells(
  so_ol_rd4,
  idents = "19"
)
```

Now subset the Rd3 object. I also forgot to store the Rd3 clusters for the OL
but do that here.

```{r}
so_rd3$clusters_rd3_res01 <- so_rd3$RNA_snn_res.0.1
so_opc_rd4 <- subset(
  so_rd3,
  cells = c(cells_opc_rd4_from_rd3, cells_opc_rd4_from_rd4)
)
so_opc_rd4 <- JoinLayers(so_opc_rd4)
so_opc_rd4 <- cleanSeurat_mds(
  so_opc_rd4,
  removeClustering = TRUE,
  clusteringPrefix = "RNA_snn_res."
)
so_opc_rd4
```

### MAD based threshopcding

Calculate threshopcds based on MAD for nFeature_RNA, nCount_RNA, percent_mito.

I'm not 100% sure MADs should be calculated yet. If the OPC vs transitioning
are very distinct might want to reconsider.

```{r}
outliers_opc <- perCellQCFilters(
  x = DataFrame(so_opc_rd4@meta.data),
  sum.field = "nCount_RNA",
  detected.field = "nFeature_RNA",
  sub.fields = "percent_mito",
  batch = so_opc_rd4$orig.ident
)

rownames(outliers_opc) <- colnames(so_opc_rd4)

so_opc_rd4 <- AddMetaData(
  so_opc_rd4,
  metadata = as.data.frame(outliers_opc),
  col.name = c("low_lib_size", "low_n_features", "high_percent_mito", "discard")
)
```

#### Make a pivot table per sample

```{r}
qc_cols <- c("low_lib_size", "low_n_features", "high_percent_mito", "discard")
pivot_summary_opc <- so_opc_rd4@meta.data %>%
  group_by(orig.ident) %>%
  summarise(
    # counts for each QC flag
    across(all_of(qc_cols), ~ sum(.x, na.rm = TRUE), .names = "n_{.col}"),
    # proportions for each QC flag
    across(all_of(qc_cols),
           ~ round(mean(.x, na.rm = TRUE)*100, 1), .names = "prop_{.col}"),
    # combo: (low_lib_size OR low_n_features) AND high_percent_mito
    n_lib_and_mito   = sum((low_lib_size | low_n_features) & high_percent_mito, na.rm = TRUE),
    prop_lib_and_mito = round(
      mean(
        (low_lib_size | low_n_features) & high_percent_mito, na.rm = TRUE
        ) * 100, 1
      ),
    .groups = "drop"
  )
pivot_summary_opc
```


#### Inspect MAD based threshopcding per sample on each QC metric.

```{r}
p1 <- plotSeuratColData(
  so_opc_rd4,
  x = "orig.ident",
  y = "nFeature_RNA",
  colour_by =  "discard",
)
p1
p2 <- plotSeuratColData(
  so_opc_rd4,
  x = "orig.ident",
  y = "nCount_RNA",
  colour_by = "discard",
)
p2
p3 <- plotSeuratColData(
  so_opc_rd4,
  x = "orig.ident",
  y = "percent_mito",
  colour_by = "discard",
) + scale_y_continuous(trans = "log1p") +
  geom_hline(yintercept = 1, color = "red")
p3 
```
Once again mitochondrial is the main driver of discards. 

### Process OPC Rd 4

I really liked the SCT in the OL, so do it again here LogNorm vs SCT.

Below is a copy paste from OL Rd4, with OL swapped to OPC

#### Seurat LogNorm opc Rd4

```{r}
so_opc_rd4[["RNA"]] <- split(so_opc_rd4[["RNA"]], f = so_opc_rd4$orig.ident)
so_opc_rd4 <- NormalizeData(so_opc_rd4)
so_opc_rd4 <- FindVariableFeatures(so_opc_rd4)
so_opc_rd4 <- ScaleData(so_opc_rd4)
so_opc_rd4 <- RunPCA(so_opc_rd4, reduction.name = "pca_log")
so_opc_rd4 <- RunUMAP(so_opc_rd4,
                     reduction = "pca_log",
                     reduction.name = "umap_log",
                     dims = 1:25)
so_opc_rd4 <- RunTSNE(so_opc_rd4,
                     reduction = "pca_log",
                     reduction.name = "tsne_log",
                     dims = 1:25)
```

#### Seurat SCTransform opc Rd4

Now also perform SCTransform for comparisons sake.

```{r}
so_opc_rd4 <- SCTransform(so_opc_rd4)
so_opc_rd4 <- RunPCA(so_opc_rd4, reduction.name = "pca_sct")
so_opc_rd4 <- RunUMAP(so_opc_rd4,
                     reduction = "pca_sct",
                     reduction.name = "umap_sct",
                     dims = 1:25)
so_opc_rd4 <- RunTSNE(so_opc_rd4,
                     reduction = "pca_sct",
                     reduction.name = "tsne_sct",
                     dims = 1:25)
```

#### Inspect UMAP Rd4 - LogNorm vs SCTransform

Inspect the UMAP created from the LogNorm data.

```{r}
p1 <- DimPlot_scCustom(
  so_opc_rd4,
  reduction = "umap_log",
  group.by = "group",
  label = TRUE
)
p1
p2 <- DimPlot_scCustom(
  so_opc_rd4,
  reduction = "umap_log",
  group.by = "orig.ident",
  label = FALSE
)
p2
p3 <- DimPlot_scCustom(
  so_opc_rd4,
  reduction = "umap_log",
  group.by = "dbl_class",
  label = TRUE
)
p3
p4 <- DimPlot_scCustom(
  so_opc_rd4,
  reduction = "umap_log",
  group.by = "clusters_rd3_res01",
  label = TRUE
)
p4
```

Inspect the UMAP created from the SCT data.

```{r}
p1 <- DimPlot_scCustom(
  so_opc_rd4,
  reduction = "umap_sct",
  group.by = "group",
  label = TRUE
)
p1
p2 <- DimPlot_scCustom(
  so_opc_rd4,
  reduction = "umap_sct",
  group.by = "orig.ident",
  label = FALSE
)
p2
p3 <- DimPlot_scCustom(
  so_opc_rd4,
  reduction = "umap_sct",
  group.by = "dbl_class",
  label = TRUE
)
p3
p4 <- DimPlot_scCustom(
  so_opc_rd4,
  reduction = "umap_sct",
  group.by = "clusters_rd3_res01",
  label = TRUE
)
p4
```

Inspect QC metrics on the SCT UMAP

```{r}
p1 <- FeaturePlot_scCustom(
  so_opc_rd4,
  feature = "nFeature_RNA",
  reduction = "umap_sct"
)
p1
p2 <- FeaturePlot_scCustom(
  so_opc_rd4,
  feature = "nCount_RNA",
  reduction = "umap_sct"
)
p2
p3 <- FeaturePlot_scCustom(
  so_opc_rd4,
  feature = "percent_mito",
  reduction = "umap_sct"
)
p3

```

Inspec them on the LogNorm map too for comparisons sake.

```{r}
p1 <- FeaturePlot_scCustom(
  so_opc_rd4,
  feature = "nFeature_RNA",
  reduction = "umap_log"
)
p1
p2 <- FeaturePlot_scCustom(
  so_opc_rd4,
  feature = "nCount_RNA",
  reduction = "umap_log"
)
p2
p3 <- FeaturePlot_scCustom(
  so_opc_rd4,
  feature = "percent_mito",
  reduction = "umap_log"
)
p3

```
**Overall takeaways:**
SCT isn't doing much different here than LogNorm, N_3 seperates out a lot less
than it did in the OL.

We are pulling out a cluster of doublets from the original OPC cluster in Rd3
(cluster1).

That is where all of OL_Rd4 "COPs" are ending up though...which isn't that
surprising I guess. I think this group of cells, only ~150, we're going to drop,
they don't fit in with the OLs or the OPCs.


What about teh transitioning cells? Cluster 3. Seperates out quite cleanly...


First confirm the doublet population is to be discarded.


## Session Info

```{r}
sessionInfo()
```

